<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=../../css/style.css><title>Become an Erlang Cowboy and tame the Wild Wild Web — Part I - This is not a Monad Tutorial</title><meta name=generator content="Hugo 0.55.6"></head><body><div class=header>unbalancedparentheses
<span>: </span><a href=../../>Home</a><div><a href=https://github.com/unbalancedparentheses/ class=contact_link>github</a>
<span class=bar>|</span>
<a href=http://twitter.com/unbalancedparen/ class=contact_link>Twitter</a>
<span class=bar>|</span>
<a href=federico.carrone@lambdaclass.com class=contact_link>Contact</a></div></div><main><h1>Become an Erlang Cowboy and tame the Wild Wild Web — Part I</h1><div class=details><span>posted on</span>
June 18, 2014<br><span>Tags:</span>
<span><a href=https://catalinasy.github.io/not_a_monad_tutorial/tags/earlang/>earlang</a></span>
<span><a href=https://catalinasy.github.io/not_a_monad_tutorial/tags/learning/>learning</a></span></div><p class=content><h1 id=erlang-from-zero-to-coding-a-commenting-system>Erlang: From zero to coding a commenting system</h1><h2 id=objective>Objective</h2><p>In the following series of posts we will be creating a commenting system like <a href=http://disqus.com/>http://disqus.com/</a>. The system will have normal HTTP/REST handlers but also some SSE and websockets handlers, and background jobs for uploading images to Amazon S3 and sending push notifications to iOS and Android clients via Amazon SNS. At the end of the series, we will connect Erlang and the system with other programming languages for those tasks that can be more difficult to do with Erlang.</p><p>By no means will this be an attempt to create a new reference for learning the syntax, types and functions of the language. There are already three great books that cover that purpose:</p><ul><li>Erlang Programming by Francesco Cesarini and Simon Thompson</li><li>Programming Erlang: Software for a Concurrent World — Joe Armstrong</li><li><a href=http://learnyousomeerlang.com/>Learn you some Erlang for Great Good — Fred Hébert</a></li></ul><p>At some point you will need to read them if you want to work with Erlang. My objective is to create a “Hands on Erlang” guide, and hopefully a small book, where we use the most important and useful Erlang concepts to create a working and real system so that you can see by yourself how highly scalable, concurrent, parallelizable, battleproof and especially how well designed the Erlang platform is. I separate the Erlang language from its plataform even if they are intertwined because you could change Erlang’s syntax or be using another language that runs on top of the BEAM like Elixir or LFE (Lisp Flavored Erlang) and still get almost all, if not all, of the Erlang benefits and even some mores. Don’t get me wrong. I really like the language per se. But its real power comes from its ecosystem and from the system in general. From my point of view, C++, Java, C#, Objective-C, Python, Ruby and even Javascript are very similar. Sure, they have different syntaxes and small different ways of doing the same thing. But you do not have to learn a new way of thinking when changing from one to another. You can learn the syntax of Erlang language in only a few hours but you will not be able to learn the concurrent/fault tolerant paradigm in one day. Nobody learnt Object Oriented paradigm in that lapse of time. If you are looking to learn a new syntax or a new rails-like framework you have come to the wrong place.</p><p>If you are interested on moving out of your comfort zone, you have come to the right place. I will do my best to help you learn a new and different way of thinking and designing applications. The length of the journey however will depend entirely on your will. You will have to play, reimplement the same idea in different ways and obviously fight with a new compiler to conquer victory.</p><h3 id=audience>Audience</h3><p>This series of posts is oriented towards developers that need to create backend servers that normally use languages and frameworks such as Python and Flask, Twisted, Celery; Ruby and Rails/Sinatra/Grape, Sidekiq/Rescue, Concurrent Ruby with JRuby or Rubinius; Javascript with Nodejs, Express/Koa or Go. I have worked with these technologies for some years, creating HTTP servers that produced JSON consumed by single page applications, iOS and Android clients. I was very comfortable with them. But for the last year I have been using Erlang, and even if I still like Ruby, Python and Javascript, I have no regrets when I say that Erlang is superior, in most areas, for building these types of systems.</p><p>My idea is to show how easily and cleanly you can create a distributed, resilient system thanks to Erlang semantics, its awesome BEAM virtual machine and some great libraries like Cowboy. If I cannot convince you to use Erlang on your next project, then I hope that at least you respect its awesome power.</p><p>On this first post I will show you some basic Erlang code so that in next one I can start working on the first handlers of our system.</p><h3 id=requirements>Requirements</h3><ul><li>Erlang 17 installed. Check <a href=https://www.erlang-solutions.com/downloads/download-erlang-otp>Erlang Solutions downloads page</a></li><li><a href=http://robots.thoughtbot.com/back-to-basics-http-requests>Basic http</a> knowledge</li></ul><p>Before starting I must say that I am very thankful to my employer —<a href=http://inaka.net/>Inaka</a> — for letting me write part of these posts during my working hours.</p><h3 id=the-ugly-duckling>The ugly duckling?</h3><p>Programming languages have a defined set of goals. Most of them put <strong>performance, developer expressiveness or developer productivity at the top of the list</strong>. Let’s see what they have to say about themselves so that we can compare with Erlang’s description:</p><blockquote><p><em><strong>Rust</strong> is a systems programming language that <strong>runs blazingly fast, prevents almost all crashes</strong>, and eliminates data races. — <a href=http://www.rust-lang.org/>http://www.rust-lang.org/</a></em></p><p><em><strong>Java</strong> is designed to enable development of portable, <strong>high-performance applications</strong> for the widest range of computing platforms possible. — <a href=https://www.java.com/en/about/>https://www.java.com/en/about/</a></em></p></blockquote><p><img src=https://cdn-images-1.medium.com/max/400/1*EPh-KvfabwINW5psttwbig.png alt><br>&gt;<em><strong>Haskell</strong> is an advanced purely-functional programming language. An open-source product of more than twenty years of cutting-edge research, <strong>it allows rapid development of robust, concise, correct software</strong>. With strong support for integration with other languages, built-in concurrency and parallelism, debuggers, profilers, rich libraries and an active community, Haskell makes it easier to produce flexible, maintainable, high-quality software. — <a href=http://www.haskell.org/haskellwiki/Haskell>http://www.haskell.org/haskellwiki/Haskell</a></em>
&gt;
&gt;<em><strong>Python</strong> is a programming language that lets you <strong>work quickly and integrate systems more effectively.</strong> — <a href=https://www.python.org/>https://www.python.org/</a></em>
&gt;
&gt;<em><strong>Ruby</strong> is a dynamic, open source programming language with a <strong>focus on simplicity and productivity</strong>. It has an <strong>elegant syntax that is natural to read and easy to write.</strong> — <a href=https://www.ruby-lang.org/en/>https://www.ruby-lang.org/en/</a></em>
&gt;
&gt;<em>The only reliable plan is to design for performance. Performance doesn’t mean speed; that’s taking the metaphor too literally. Speed counts, but a programming language is first of all a tool for thinking in. We want thinking in <strong>Arc</strong> to <strong>feel like driving a 911.</strong>— <a href=http://www.paulgraham.com/design.html>http://www.paulgraham.com/design.html</a></em></p><p><img src=https://cdn-images-1.medium.com/max/800/1*ezjVLCDsv-Qur7C2BvhnsQ.jpeg alt></p><p><code>1973 Porsche 911E</code></p><blockquote><p><em>The <strong>Go</strong> programming language is an open source project to <strong>make programmers more productive</strong>. Go is <strong>expressive, concise, clean, and efficient</strong>. Its concurrency mechanisms make it <strong>easy to write programs that get the most out of multicore and networked machines</strong>, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It’s a <strong>fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.</strong> — <a href=http://golang.org/doc/>http://golang.org/doc/</a></em></p></blockquote><p>Let’s see what Erlang has to say about itself:</p><blockquote><p><strong>Erlang</strong> is a programming language <strong>used to build massively scalable soft real-time systems with requirements on high availability</strong>. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang’s runtime system has built-in support for concurrency, distribution and fault tolerance. — <a href=http://www.erlang.org/>http://www.erlang.org/</a></p></blockquote><p>Erlang seems to be the ugly duckling compared to other programming languages since it doesn’t describe itself as being fast, clean or expressive.</p><p><img src=https://cdn-images-1.medium.com/max/716/1*qV-Mz3gUxyM1Ug0XANoZgg.jpeg alt></p><p>Erlang was created for building fault-tolerant systems. This is natural since Erlang’s roots are in the telecommunication world. Most important design choices of the language were taken to fulfill this requirement. However this does not mean it is not clean or expressive. Let’s take a closer look.</p><h2 id=syntax>Syntax</h2><p><a href=https://github.com/erlang/otp/blob/maint/lib/stdlib/src/erl_parse.yrl#L-0-L-535>Erlang grammar</a> is simple, it has less than 550 lines of code. That makes erlang syntax easy to understand even if it is different from mainstream languages. But what is more important it is really consistent. Enough talk:</p><blockquote><p>%% this is a comment
-module(foo). %% we define a module called foo
-export([bar/0]). %% and export the function bar that has 0
%% arguments</p><p>bar() -&gt; %% we define the function bar
io:format(&ldquo;Hello World!~n&rdquo;).`</p></blockquote><p>Lets compile it and run inside the erlang shell the bar function from module foo.</p><blockquote><p>$ erlc foo.erl
$ erl</p><p>1&gt; foo:bar(). %% we call the bar function
Hello World!
ok</p></blockquote><p>Let me show you an example that is a little more complex:</p><blockquote><p>-module(test).
-compile(export_all).</p><p>%% factorial implemented as you would normally do in most
%% imperative languages.
fac_if(N) -&gt;
if
N =:= 0 -&gt;
1;
true -&gt;
N * fac_if(N - 1)
end.</p><p>%% factorial implemented with a case. if N matches 0 it
%% returns 0. If N matches any other value it will call
%% fac_case with N-1
fac_case(N) -&gt;
case N of
0 -&gt;
1;
N -&gt;
N * fac_case(N - 1)
end.</p><p>%% factorial implemented with function clauses
fac(0) -&gt;
1;
fac(N) -&gt;
N * fac(N - 1).</p></blockquote><p>Now let’s save it as test.erl, compile it and call the erlang shell:</p><blockquote><p>$ erlc test.erl
$ erl</p></blockquote><p>The last case uses something called pattern matching in the function head. In just a few lines you will learn more about pattern matching. Now we can call the fac function:</p><blockquote><p>2&gt; test:fac(20).
2432902008176640000</p><p>3&gt; test:fac(40).
815915283247897734345611269596115894272000000000</p></blockquote><p>The syntax is not difficult. It is just different from Algol or C based syntax. As you will see there are not many reserverd words or language constructs. I think only Lisps are way simpler languages from the syntax and grammar point of view.</p><p>I wanted to add that as you have noticed erlang uses “,”, “;” and “.” as terminators. I am not a big fan of them, since I have to change them when moving lines of code up or down. In general I like indentation a la Python as a way to delimit blocks of code. However Erlang terminators are not a big pain in the a** once you get used to them. Also I agree with Robert Virding, co creator of Erlang, that Erlang syntax is small, simple, regular and concise. It is difficult not to agree with that even if you do not like Erlang syntax. All the mainstream languages I have used (e.g. C++, Java, C# or Objective-C) have a much more complex and less consistent syntax. Returning to the terminator issue, Fred Hebert has a <a href=https://github.com/erlang/otp/blob/maint/lib/stdlib/src/erl_parse.yrl#L-0-L-535>great article</a> with some tips on how to understand how to use and read them.</p><p>Let’s move onto more important things:</p><h2 id=expressiveness>Expressiveness</h2><p>When thinking about Erlang expressiveness the first thing that comes to mind is message passing, process creation and management. Nevertheless pattern matching is a big player too in this field and serves a big purpose in making things easier for receiving messages. Let’s start by showing a simple example of pattern matching before moving on to message passing and process management.</p><blockquote><p>4&gt; Body.
* 1: variable &lsquo;Body&rsquo; is unbound</p><p>5&gt; Headers.
* 1: variable &lsquo;Headers&rsquo; is unbound</p></blockquote><p>First we tried to access the content of Body and Headers variables (all variables in Erlang must start with a capital letter). The shell answers with the obvious: the variables are unbound. Now it is time to do something more interesting.</p><p><strong>Exit the shell we have being using up to now doing twice Control-C. Since we are going to use an http library (ibrowse) on the following example, instead of setting up everything:</strong></p><blockquote><p>$ git clone git@github.com:unbalancedparentheses/erlskeletor_cowboy.git
$ cd erlskeletor_cowboy/
$ make</p></blockquote><p>Make will fetch all the dependencies and compile the project. Up to now we executed erl to launch the erlang shell. Now we are going to use:</p><blockquote><p>$ make shell</p></blockquote><p>Make shell will start erlang and all the dependencies we need. You will see a lot of output. Now we can return to our work:</p><blockquote><p>1&gt; ibrowse:send_req(&ldquo;<a href='http://www.google.com/"'>http://www.google.com/&quot;</a>, [], get).</p><p>{ok,&ldquo;302&rdquo;,
[{&ldquo;Cache-Control&rdquo;,&ldquo;private&rdquo;},
{&ldquo;Content-Type&rdquo;,&ldquo;text/html; charset=UTF-8&rdquo;},
{&ldquo;Location&rdquo;,
&ldquo;<a href='https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA"}'>https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA&quot;}</a>,
{&ldquo;Content-Length&rdquo;,&ldquo;263&rdquo;},
{&ldquo;Date&rdquo;,&ldquo;Thu, 15 May 2014 23:26:46 GMT&rdquo;},
{&ldquo;Server&rdquo;,&ldquo;GFE/2.0&rdquo;},
{&ldquo;Alternate-Protocol&rdquo;,&ldquo;443:quic&rdquo;}],
&ldquo;<html><head>&lt;<code>meta http-equiv=\&quot;content-type\&quot; content=\&quot;text/html;charset=utf-8\&quot;&gt;\n&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;\n&lt;H1&gt;302 Moved&lt;/H1&gt;\nThe document has moved\n&lt;A HREF=\&quot;https://www.google.com.ar/?gfe_rd=cr&amp;amp;ei=Nk11U4zsFIeF8Qf6hoC4BA\&quot;&gt;here&lt;/A&gt;.\r\n&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</code>}</p></blockquote><p>We call the <a href=https://github.com/cmullaparthi/ibrowse/blob/master/src/ibrowse.erl#L-165>send_req</a> function from the module <a href=https://github.com/cmullaparthi/ibrowse>ibrowse</a>, an HTTP erlang client. The first argument is a string with the URL. Strings are a <a href=http://www.erlang.org/faq/academic.html#id58248>linked list of integers</a> since Erlang doesn’t have a real string type. It is not very common to use strings in Erlang. You have <a href=https://en.wikipedia.org/wiki/Symbol_%28programming%29>atoms</a> (<a href=http://www.reactive.io/tips/2009/01/11/the-difference-between-ruby-symbols-and-strings/>Ruby</a> or <a href=https://stackoverflow.com/questions/8846628/what-exactly-is-a-symbol-in-lisp-scheme>Lisp</a> symbols), binaries and <a href=http://prog21.dadgum.com/70.html>IOLists</a> . Atoms and binaries are really common and handy. For the moment this is not important but I wanted to mention this so that you do not start rambling afterwards.</p><p>The second argument of the call to send_req is a list of headers we want to send with the request. We are not sending any header in this case. At last, with the third argument, we specify the verb of the request. We used the atom get for that. Variables can not begin with a lowercase letter because atoms do. Atoms start with lower-case letters or enclosed in single quotes. As you can see we sent a get request to <a href=http://www.google.com>http://www.google.com</a>.</p><p>Let’s inspect the result of the call:</p><blockquote><p>{ok,&ldquo;302&rdquo;,
[{&ldquo;Cache-Control&rdquo;,&ldquo;private&rdquo;},
{&ldquo;Content-Type&rdquo;,&ldquo;text/html; charset=UTF-8&rdquo;},
{&ldquo;Location&rdquo;,
&ldquo;<a href='https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA"}'>https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA&quot;}</a>,
{&ldquo;Content-Length&rdquo;,&ldquo;263&rdquo;},
{&ldquo;Date&rdquo;,&ldquo;Thu, 15 May 2014 23:26:46 GMT&rdquo;},
{&ldquo;Server&rdquo;,&ldquo;GFE/2.0&rdquo;},
{&ldquo;Alternate-Protocol&rdquo;,&ldquo;443:quic&rdquo;}],
&ldquo;<html><head>&lt;<code>meta http-equiv=\&quot;content-type\&quot; content=\&quot;text/html;charset=utf-8\&quot;&gt;\n&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;\n&lt;H1&gt;302 Moved&lt;/H1&gt;\nThe document has moved\n&lt;A HREF=\&quot;https://www.google.com.ar/?gfe_rd=cr&amp;amp;ei=Nk11U4zsFIeF8Qf6hoC4BA\&quot;&gt;here&lt;/A&gt;.\r\n&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</code>}</p></blockquote><p>The result is a tuple with four elements. <strong>{Term1,…,TermN}</strong> in erlang denotes a tuple. Tuples have a fixed number of terms or elements. Erlang tuples are very similar to Python tuples. The first element is the atom <strong>ok</strong>, that lets us know that everything went fine. The second element is the string with content 302. 302 Found HTTP status code is usually used to redirect the user to somewhere else. The third element of the result is the list of headers in the answer that google sent us.</p><blockquote><p>[{&ldquo;Cache-Control&rdquo;,&ldquo;private&rdquo;},
{&ldquo;Content-Type&rdquo;,&ldquo;text/html; charset=UTF-8&rdquo;},
{&ldquo;Location&rdquo;,
&ldquo;<a href='https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA"}'>https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA&quot;}</a>,
{&ldquo;Content-Length&rdquo;,&ldquo;263&rdquo;},
{&ldquo;Date&rdquo;,&ldquo;Thu, 15 May 2014 23:26:46 GMT&rdquo;},
{&ldquo;Server&rdquo;,&ldquo;GFE/2.0&rdquo;},
{&ldquo;Alternate-Protocol&rdquo;,&ldquo;443:quic&rdquo;}]</p></blockquote><p>As you can see the headers are represented as a list of tuples. Each tuple has two elements: a key and a value. This is a type of <a href=http://www.erlang.org/doc/man/proplists.html>proplist</a>.</p><p>The first header has a key of type string “Cache-Control” with a string value “private”. Also check that the “Location” key has the URL value of the redirect where google wants us to go. I know it can be different from what you are used to, but it is not that difficult to understand. After a few hours of reading proplists, tuples or lists in Erlang it will feel very natural.</p><p>The last element of the answer to the call to ibrowse:send_req is a big string with the HTML that google sent us:</p><p><code>&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=\&quot;content-type\&quot; content=\&quot;text/html;charset=utf-8\&quot;&gt;\n&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;\n&lt;H1&gt;302 Moved&lt;/H1&gt;\nThe document has moved\n&lt;A HREF=\&quot;https://www.google.com.ar/?gfe_rd=cr&amp;amp;ei=Nk11U4zsFIeF8Qf6hoC4BA\&quot;&gt;here&lt;/A&gt;.\r\n&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</code></p><p>Now let’s store the result:</p><p><code>2&gt; {ok, &quot;302&quot;, Headers, Body} = ibrowse:send_req(&quot;http://www.google.com/&quot;, [], get).</code></p><p><img src=https://cdn-images-1.medium.com/max/400/1*9mLW7UAh0eDj2ljx5GfCJw.jpeg alt></p><p><code>Pattern, pattern, pattern matching everything!!!</code></p><p>We sent a get request to google, got an answer. ‘ok’ is an atom, and “302&rdquo; a string. They are not assigned, since they are not variables. So why did we use the equal sign to assign them? Well because in Erlang the equal sign is not exactly the same as assignment. Since Erlang supports the pattern matching mechanism, the equal sign is used as a match operator. It tries to find equivalence between the two sides, and then binds values to unbound variables, thus assigning them a value.</p><p>So after getting the result from our call to ibrowse:send_req, Erlang asserts that we got a tuple with four elements that started with the elements ok and “302&rdquo;. Then since it knows that Headers and Body are unbound it assigned the headers proplist to the variable Headers and the HTML returned by Google to the variable Body.</p><blockquote><p>3&gt; Headers.
[{&ldquo;Cache-Control&rdquo;,&ldquo;private&rdquo;},
{&ldquo;Content-Type&rdquo;,&ldquo;text/html; charset=UTF-8&rdquo;},
{&ldquo;Location&rdquo;,
&ldquo;<a href='https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA"}'>https://www.google.com.ar/?gfe_rd=cr&amp;ei=Nk11U4zsFIeF8Qf6hoC4BA&quot;}</a>,
{&ldquo;Content-Length&rdquo;,&ldquo;263&rdquo;},
{&ldquo;Date&rdquo;,&ldquo;Thu, 15 May 2014 23:26:46 GMT&rdquo;},
{&ldquo;Server&rdquo;,&ldquo;GFE/2.0&rdquo;},
{&ldquo;Alternate-Protocol&rdquo;,&ldquo;443:quic&rdquo;}]</p></blockquote><p>To sum up, pattern matching is way more than another syntax for writing your C switch or if/else/elif from Python and most languages. With pattern matching you get normal branching, conditionals on complex structure, not only by comparing simple values, and you can also extract specific values when you do the comparison or/and assignment. You <a href=http://deliberate-software.com/function-pattern-matching/>make the compiler work for you</a>.</p><p>At last I wanted to show a beautiful example of pattern matching where we dissect a TCP segment by its bits:</p><blockquote><p>&lt;<sourceport:16, destinationport:16, sequencenumber:32, acknumber:32, dataoffset:4, _reserved:4, flags:8, windowsize:16, checksum:16, urgentpointer:16, payload/binary>&gt; = TcpSegment.</p></blockquote><p>Ain’t this a good example of Erlang expressiveness?</p><h3 id=god-cannot-alter-the-past-though-historians-can-and-some-developers-too-samuel-butler>God cannot alter the past, though historians can (and some developers too)— Samuel Butler</h3><p>Variables are either bound or unbound. As you might know values are inmutable in Erlang and once the variable is bound, you can not assign a new value to it. Only one assignment is allowed. You can not modify a variable or a value once it was created.</p><blockquote><p>4&gt; Message = &ldquo;Hello ladies!&rdquo;.
&ldquo;Hello ladies!&rdquo;</p><p>5&gt; Message = &ldquo;Die die my darling&rdquo;.
** exception error: no match of right hand side value &ldquo;Die die my darling&rdquo;</p></blockquote><p>Inmutability and single assignment at first might seem awkward, uncomfortable, but they are very useful properties since they minimize side effects. Even if it is not impossible to write Erlang code with race conditions, it is way more difficult than with general imperative and stateful languages. You will see this in the next section.</p><p>A really interesting property, helped by single assignment and inmutability, is <a href=http://deliberate-software.com/function-pattern-matching/>referential transparency</a>. In plain english this means that the result of a function is always the same when you provide the same arguments/input. You might think this is a property of most programming languages, but it is not.</p><p>The output of calling a method in most object oriented languages like for example C++, Java, Ruby depends on the state of the object. Previous calls to other method change the state of the object that is used by the methods you are calling. So the result will not depend only on the arguments, but also on what other methods have been called before. With referential transparency, you are on the greener side of the grass since you have some degree of determinism. Also writing test cases is way easier since, in general, you do not need to mock entire objects or use dependency injection since you only call functions with the arguments you want.</p><p>You might think we are using complicated words for showing off. But as you will see in the following posts thanks to referential transparency and pattern matching we will be able to refactor nested branching implemented with cases into calling small and simple functions. In many languages, inspired by how Java and C++ implemented OOP, the code is so damn interdependent that it is more difficult to refactor it.</p><h2 id=processes-and-messages>Processes and Messages</h2><p>Functions in functional programming languages are first class citizens. This means that they are not discriminated. They can be assigned to variables, passed as arguments to other functions and returned as values from other functions. Say no to racism. Treat functions as any other type!
<img src=https://cdn-images-1.medium.com/max/800/1*FLmbrG6z0Pt25nbfeG775g.jpeg alt>
&gt;6&gt; F = fun(X, Y, Operation) -&gt; Operation(X,Y) end.
&gt;#Fun<erl_eval.18.106461118>
&gt;
&gt;7&gt; Plus = fun(X, Y) -&gt; X + Y end.
&gt;#Fun<erl_eval.12.106461118>
&gt;
&gt;8&gt; F(2, 2, Plus).
&gt;4
&gt;
&gt;9&gt; DividePlusTwo = fun(A,B) -&gt; A / B + 2 end.
&gt;#Fun<erl_eval.12.106461118>
&gt;
&gt;10&gt; F(2, 2, DividePlusTwo).
&gt;3.0</p><p>Creating a new process in Erlang is really simple. You use the spawn primitive with the function you want to launch in another process.</p><blockquote><p>11&gt; G = fun() -&gt; 2 + 2 end.
#Fun<erl_eval.20.106461118></p><p>12&gt; G().
4</p><p>13&gt; spawn(G).
<0.60.0></p><p>14&gt; spawn(G).
<0.65.0></p></blockquote><p>Spawn creates the new process and returns the PID (unique Process Identifier) of that process. You might ask where does the return value go? Well apparently it disappeared. Black magic? No. Processes do not return anything. You have to send the result as a message to another. Before that let me show you that the shell itself is a process and that we can get its PID:</p><blockquote><p>15&gt; self().
<0.32.0></p><p>16&gt; exit(self()).
** exception exit: <0.32.0></p><p>17&gt; self().
<0.35.0></p></blockquote><p>With self() we got the PID of the actual process, in this case obviously the shell’s PID. We then exited that process and a new shell process automatically was launched, that is why the PID changed from <0.32.0> to <0.35.0>.</p><blockquote><p>18&gt; Pid = self().
<0.32.0></p><p>19&gt; H = fun() -&gt; Pid ! 2+2 end.
#Fun<erl_eval.20.106461118></p><p>20&gt; spawn(H).
<0.36.0></p><p>21&gt; flush().
Shell got 4
ok</p></blockquote><p>The ! or bang symbol, is a primitive that sends the message at its right to the process identified by the PID at its left. Each process has a mailbox, a queue that stores the messages the process receives. With flush you can see all the messages the process has.</p><p>However in general you want to do something based on the message you received, not only see them on the shell. That is where the receive statement appears to save the game!</p><blockquote><p>22&gt; Echofun = fun Echo() -&gt;
receive
X -&gt;
io:format(&ldquo;Message ~p~n&rdquo;, [X])
end
end.</p><p>#Fun<erl_eval.20.106461118></p><p>23&gt; EchoPid = spawn(Echofun).
<0.35.0></p><p>24&gt; EchoPid ! test.
Message test
test</p></blockquote><p>We created an Echofun function that receives a message and prints it. Receive blocks until it receives a message. Receive is very similar to the case statement. If a message correctly pattern matches, the associated expression gets executed.</p><p>Returning to our example, we saved the Echofun function in the Echo variable. Then we spawned the function and stored the Pid. Finally we sent an atom as a message using the bang symbol. The message is received by the process and as any message will pattern match to the variable X the io:fomat line gets executed. The first parameter of io:format is a string that contains a ~p. ~p gets replaced by each element of the list, that is the second argument of the call to io:format.</p><blockquote><p>25&gt; EchoPid ! test.
test</p></blockquote><p>If we send the message again, the process will not print “Message test” as before because the function already finished it’s execution. That’s why we need to recursively call the function so that it keeps running after receiving a message.</p><blockquote><p>26&gt; Echofun2 = fun Echo() -&gt;
receive
X -&gt;
io:format(&ldquo;Message ~p~n&rdquo;, [X]),
Echo()
end
end.</p><p>#Fun<erl_eval.44.106461118></p><p>27&gt; EchoPid2 = spawn(Echofun2).
<0.35.0></p><p>28&gt; EchoPid2 ! test
Message test
test</p><p>29&gt; EchoPid2 ! test
Message test
test</p><p>30&gt; EchoPid2 ! test
Message test
test</p></blockquote><p>Now after receiving and printing the first message, the function call itself and waits for the next message to be received.</p><p>Erlang and most functional programming languages have a great property called <a href=https://en.wikipedia.org/wiki/Tail_call>tail recursion</a>. Thanks to it your process can have a long and great life without making your stack grow and explode in your face.</p><p>Let’s add a new clause inside the receive so that we can kill the process:</p><blockquote><p>31&gt; Echofun3 = fun Echo() -&gt;
receive
die -&gt;
io:format(&ldquo;Process with PID ~p has died~n&rdquo;, [self()]);
X -&gt;
io:format(&ldquo;Message ~p~n&rdquo;, [X]),
Echo()
end
end.</p><p>#Fun<erl_eval.44.106461118></p></blockquote><p>Now instead of spawning the function in a process and storing the PID, we will register the process:</p><blockquote><p><em>Besides addressing a process by using its pid, there are also built in functions (BIFs) for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates</em></p><p>32&gt; register(echo_process, spawn(Echofun3)).</p></blockquote><p>We register the process created by spawn(Echofun3) under the name echo_process.</p><blockquote><p>33&gt; echo_process ! test.
Message test
test</p><p>34&gt; echo_process ! die.
Process with PID <0.37.0> has died
die</p></blockquote><p><img src=https://cdn-images-1.medium.com/max/800/1*wysu8drrpca_-GPtNsoYNQ.gif alt></p><p><code>killing a process thanks to message passing</code></p><blockquote><p>35&gt; echo_process ! test.
** exception error: bad argument
in operator !/2
called as echo_process ! test</p></blockquote><p>The receive in the process function that is running under a new process pattern matchs the messages it receives. Since the first message does not match the die atom, it then checks if it matchs the X variable. Since the X variable is unbound, the message will always match it. The message gets printed out.</p><p>We send a die atom as a message to the same process. Since die matchs the first clause of the receive, a sentence stating that the process has died. As we do not call the function again effectively the process dies.</p><p>When we try to send again a test atom as message to the process that was registered via the echo_process we get a bad argument exception. This happens since the process died the echo_process atom does not reference a process anymore, and obviously that’s why we can not send a message.</p><h4 id=the-final-fight>The final fight</h4><p>Now we are going to play with three processes: a client (the shell), a project manager and a developer. The shell will send a message to the project manager. The project manager will forward the task to developer. Simple but cool:</p><blockquote><p>36&gt; Dev = fun Devfun() -&gt;
receive
Task -&gt;
io:format(&ldquo;DEV(~p):~n I got a new task: ~p ~n&mdash;~n&rdquo;, [self(), Task]),
Devfun()
end
end.</p></blockquote><p>As you can see the Dev variable contains a function that receives a message and prints it out. After that it calls itself.</p><blockquote><p>37&gt; Pm = fun Pmfun() -&gt;
receive
Task -&gt;
io:format(&ldquo;PM(~p):~n I received the following task: ~p.~n My job is to forward it to the developer ~n&mdash;~n&rdquo;, [self(), Task]),
dev ! Task,
Pmfun()
end
end.</p></blockquote><p>Well the Project Manager is not very different from the Developer. He receives a task, prints it out and finally it sends the Task he received to the dev process. We need to spawn and register the dev and pm processes. If we do not register the process that spawns the Dev function, then we would not be able to send it a message as we are doing. So let’s do it:</p><blockquote><p>38&gt; register(dev, spawn(Dev)),
register(pm, spawn(Pm)).</p></blockquote><p>Finally we are going to create a really simple function that sends the task to the pm:</p><blockquote><p>39&gt; NewTask = fun (Task) -&gt;
io:format(&ldquo;Client(~p):~n ~p~n&mdash;~n&rdquo;, [self(), Task]),
pm ! Task
end.</p></blockquote><p>Time to send our task!</p><blockquote><p>40&gt; NewTask(&ldquo;Add cover to TPS report&rdquo;).</p></blockquote><p>And we get this ouput printed out:</p><blockquote><p>Client(<0.32.0>):</p><h2 id=add-cover-to-tps-report>&ldquo;Add cover to TPS report&rdquo;</h2><p>PM(<0.37.0>):
I received the following task: &ldquo;Add cover to &gt;TPS report&rdquo;.</p><h2 id=my-job-is-to-forward-it-to-the-developer>My job is to forward it to the developer</h2><p>DEV(<0.36.0>):</p><h2 id=i-got-a-new-task-add-cover-to-tps-report>I got a new task: &ldquo;Add cover to TPS report&rdquo;</h2><p><img src=https://cdn-images-1.medium.com/max/800/1*1MQrMONE3YjecZdrkdOhTg.jpeg alt></p></blockquote><p>The Dev process could be running in one server in the US, the PM process in an Europe based server and the Client, my shell, could be running on my computer here in Buenos Aires, Argentina. In another language this would require a really big code change. When using Erlang this only requires adding a few lines of code. Technically, we would have to register the processes globally and set up some kind of vpn so that the virtual machines see themselves as if on a local network. The point is that erlang has distribution built in, and getting to the point where systems run on clusters is not difficult.</p><p>For the following posts we leave error detection and supervision of processes, an area where Erlang really really shines.</p><h2 id=moving-foward>Moving foward</h2><p>You might be asking yourself why would you want to create processes and send messages between them? Sooner rather than later in relative big project you will need to parallelize some code for example a call to a third party api that is taking too much time for example. That is why you will need to use a concurrency construct. In most programming languages threads, processes or any construct related to concurrency or parallelism is something you rarely use. In most universities it is something you will learn only after your first programming courses. You might have used a ThreadPool in Java or even a pthread in C. But it is not something you generally use or do as often as defining a class, instantiating an object, calling a function or writing a conditional statement. Even if this is changing and we now have really interesting libraries, frameworks and toolkits like Akka for the Java world, Concurrent-Ruby or Celluloid for Ruby or even languages as Clojure that already set a pretty high bar, truth be told concurrency is not the cornerstone of most languages. In Erlang you will use them as frequently as you use an if construct in C, because they are cheap and great for designing your systems.</p><p><img src=https://cdn-images-1.medium.com/max/800/1*o61yZIq3SpkTDPn-pzAJTA.gif alt></p><p><code>Message passing</code></p><p>Up to now we have only played with processes so that you can see how easy it is to use concurrency based primitives in Erlang since you do not require external library support like in most languages. You will see some of its real uses in the nexts posts. I must add that pattern matching plays an essential role too, and it is very well integrated with the the rest because it makes it very easy to select what to do based on the message received.</p><p>To sum up thanks to message passing, pattern matching, light processes you can avoid threads, mutex, semaphores and a lot of deadly weapons that sooner rather than later will backfire.</p><p>Stay tuned, we will work on some real stuff next week: comments and threads, http endpoints of our commenting system!</p><p><img src=https://cdn-images-1.medium.com/max/400/1*1LLFcr72yLfiLfFloQHaeg.jpeg alt></p><p><code>This is me after my first hour playing with Erlang!</code></p></p></main><div class=footer></div></body></html>